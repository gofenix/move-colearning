---
layout: cover
theme: "seriph"
background: "https://pbs.twimg.com/media/FtuzzeZaUAA7DAu?format=jpg&name=large"
class: "text-black"
---

# Sui Move 合约测试

Fenix

<!--

大家好，我是Fenix。

本次和大家一起学习的是Move合约的测试。

-->

---

# 为什么要做合约测试？

在 Move 开发过程中通过 check 检查没有语法错误后，依然不能掉以轻心，因为代码中的错误不只有语法错误，更多的是业务逻辑的错误和代码编写中的逻辑错误，对于这些错误，可以使用功能强大的单元测试来针对小范围的代码进行测试。

![测试金字塔](https://insights.thoughtworks.cn/wp-content/uploads/2018/10/3.png)

<!--
从这幅图看测试大致可分为三层：
- 单元测试；
- 服务测试；
- 功能/页面测试；

### 单元测试

单元测试处在金字塔底层，它的数量是最多的，理想情况程序逻辑都应有对应的单测cover。

单测的隔离程度是最高的，程序中外部api调用，数据库调用，发送消息，等等这些需要调用外部服务的都应被mock掉，以保证测试的隔离性。所以单测只依赖runtime即可运行。

另外，由于外部依赖都被mock掉，单测的执行速度也是非常快的。所以单测能够最快的对代码修改是否正确做出反馈。

### 服务测试

这一层的测试可以理解为集成测试，需要我们把服务部署起来，外部的依赖也要搭建好（比如数据库，队列等等）。比如我测试save方法，测试执行完毕后，预期数据库中应有刚刚我们存储的数据。

这一层级的测试由于产生了外部调用，而且执行链路较长，所以，执行速度上来说比单测要慢很多。

集成测试的隔离性比单测差很多，执行这类测试需要我们准备数据库，消息队列，以及其他依赖。但是对于我是我们维护的服务，比如google 登录api这些我们还是可以通过mock来做。

###  功能/UI测试

功能测试是进行真实的用户使用场景测试。这套环境和最终生产环境几乎无差异。
-->

---
layout: two-cols
---
# 黑盒与白盒

- 如果知道盒子的用途，但不知道盒子的构造，就是黑盒测试
- 如果知道盒子的用途，也知道盒子的构造，就是白盒测试

白盒测试一般只在单元测试中使用，黑盒测试在单元测试、集成测试等各个阶段都可以使用。

::right::

<img src="https://pic3.zhimg.com/80/v2-ef8638c73c9f8a5bcd70cf8c3ff1a3aa_1440w.webp" />

---

# 测试覆盖率
<br>

所谓覆盖，可以简单理解为 “被执行过”。

- 语句覆盖

- 分支覆盖

- 条件覆盖

```rust
fun foo(a: u64) {
    if(a > 0) {
        some();
    } else {
        another();
    }
}
```

<!--

在单元测试中，覆盖率是一个常用的评估指标。

常见的覆盖可以分为这几种：

- 语句覆盖
- 分支覆盖
- 条件覆盖

假设我们有一个这么一个待测函数：

- 语句覆盖 是指 每条语句都被执行一次。

- 分支覆盖 是指 每个分支 真/假 条件都被执行一次。 

- 条件覆盖 是指 每个分支的条件组合方式都被执行一次。

语句覆盖是最容易达到、也是最弱的覆盖方式。在工程实践中，考虑到测试成本及测试效果，分支覆盖的覆盖率是最常使用的考察指标。

所以我们在写测试用例的时候，一定要每个if判断都要覆盖到。

-->

---

# 如何写出好的测试？

- 断言
- 输入数据
- 预期输出

```rust
// 待测函数
fun add(a: 64, b: 64): u64 {
    a + b
}

// 测试用例
#[test]
fun test_add() {
//       被测对象      预期输出
//         |||          |
    assert!(add(1, 2) == 3, 0);
//  ||||||     |  |
//   断言      输入数据
}
```

<!--

一个单元测试用例至少包含：

- 断言
- 输入数据
- 预期输出

抽象一下，就是测试三要素。

-->

---

# 测试三要素：Given-When-Then

- Given 描述测试的前置条件或初始状态
- When 描述测试过程中发生的行为
- Then 描述测试结束后断言输出结果

使用 GWT 来描述上一个的用例：

```rust
assert!(
  add(      // When  - 测试过程发生的行为 - 调用被测函数 add()
    1, 2    // Given - 测试前置条件和初始状态 - 用例输入参数
  )
  == 3,      // Then  - 测试结束断言输出结果 - 断言预期输出
  0
);
```

<!--
单元测试中 被测函数、断言、输入数据、预期输出 几个要素，可以通过经典模板 Given-When-Then(GWT) 来做一些严谨的描述。

- Given 描述测试的前置条件或初始状态
- When 描述测试过程中发生的行为
- Then 描述测试结束后断言输出结果
-->

---

<!-- 说了那么多基础的知识，想必大家对测试有了更加深刻的了解。接下来，咱们来进入到主题。

Move合约测试。 -->

# Sui Move 合约测试

<br>

```rust
module my_pkg::add {
  #[test_only] // 标注只在测试用到的数据
  const EAddTestError: u64 = 0;
  
  public fun add(a: u64, b: u64): u64 {
    a + b
  }
  
  #[test] // 必须打上test标签，才能被正确识别为测试用例
  fun test_add() {
    assert!(add(4, 5) == 9, EAddTestError);
  }
}
```

📢：合约里的中文注释需要在编译时去掉，目前Sui Move不支持中文注释！

```bash
$ sui move test --path <pkg_path>
```

<!-- 

命令执行无报错则说明测试用例通过。 

基本流程主要是3步：
1, 编写测试方法 (需打上test标签) 
2, 对被测试的方法进行调用和评估结果是否符合预期 
3, 运行测试命令

-->

--- 

# Sui Move 合约测试

## 进阶1：打印中间数据

```rust
module my_pkg::add {
  ...
  use std::debug; // 引入debug模块
  
  public fun add(a: u64, b: u64): u64 {
    let res = a + b;
    debug::print(&res); // 打印计算结果
    res
  }
  ...
}
```

<!-- 
在编程时，有时会遇到一下无法定位的bug。对上面的例子做一下修改。

再次执行测试命令，会在terminal 打印出:[debug] 9 
-->

---

# Sui Move 合约测试

## 进阶2：Test Scenario

实际测试中，不仅需要测试pure function，更多的是需要对用户的操作进行测试。

<!-- 在这里，我们需要理解和交互的主要对象是Scenario对象。Scenario对象模拟多个交易序列，并且它可以像下面这样使用发送方地址进行初始化： -->

```rust
  // 初始化一个模拟的交易发起者地址
  let addr1 = @0xA;
  // 以 addr1 作为发送方开始一个多笔交易场景。
  let scenario = test_scenario::begin(addr1);
  ...
  // 清理 scenario 对象
  test_scenario::end(scenario);  
```

<br>

💡：Scenario对象不可被drop（即无法使用drop进行释放），因此在其作用域结束时必须显式地使用test_scenario::end函数进行清理。

---

# Sui Move 合约测试

## 进阶3：测试逻辑与业务逻辑分离

业务逻辑复杂的情况下，一个文件代码太多，会增加代码的阅读难度。

一般把counter的测试单独抽离成一个 counter_test模块，专注于测试逻辑。

```rust
#[test_only]
module my_pkg::counter_test {
    #[test] 
    fun test1(){

    }
}
```

---

# Live Coding

## 基础测试

## 打印中间数据

## 模拟用户操作

## 测试逻辑与业务逻辑分离

--- 

# 总结

<br >

在编码过程中，多多考虑代码的可测性，可以让单元测试事半功倍：

- 开发过程及时编写测试用例，边开发边测试，不要等全部开发完毕了才开始写测试用例
- 函数功能简单，避免随机性，以免测试结果不稳定
- 函数减少输入输出，使简单的输入数据组合可以完成测试覆盖
- 遵循 SOLID 原则

<!-- 

本次学习的基础的测试流程和常用的测试进阶知识，可以应付中小规模的Sui Move合约开发。根据我们的开发经验，后续随着应用的复杂度提升，测试工作也会变得艰巨。因而需要提高对测试逻辑的复用：

- 例如通用测试逻辑的封装，例如参考web2测试，进行一些测试框架。
- 业务级别测试逻辑的复用，很多测试场景的setup，和destry可以复用。

-->

---
layout: cover
background: "https://d.ifengimg.com/w935_h595_q90_webp/x0.ifengimg.com/ucms/2023_01/00E78A814D79BC0414718417DA22B82523936AB4_size58_w935_h595.jpg"
---
# 最后，祝大家变得更强！

